---
title: "Replace this with an interesting title"
---




## Motivation and Context




```{r}
#| label: do this first
#| echo: false
#| message: false

here::i_am("Final_Project_Text_And_Code.qmd")
```






## Main Objective

The main objective of this project is predict what the attendance would have been in the 2020 season if there wasn't a COVID-19 restriction.

## Packages Used In This Analysis




```{r}
#| label: load packages
#| message: false
#| warning: false

library(readr)
library(stringr)
library(tidyr)
library(dplyr)
library(kknn)
library(probably)
library(readxl)
library(janitor)
```





| Package | Use |
|-------------------------------|----------------------------------------|
| [here](https://github.com/jennybc/here_here) | to easily load and save data |
| [readr](https://readr.tidyverse.org/) | to import the CSV file data |
| [dplyr](https://dplyr.tidyverse.org/) | to massage and summarize data |
| [rsample](https://rsample.tidymodels.org/) | to split data into training and test sets |
| [ggplot2](https://ggplot2.tidyverse.org/) | to create nice-looking and informative graphs |

## Data Description




```{r}
#| label: import data
#| warning: false
attendance <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2020/2020-02-04/attendance.csv')
standings <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2020/2020-02-04/standings.csv')
games <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2020/2020-02-04/games.csv')

stadiums <- clean_names(read_excel(here::here("Final_Project_Data/Stadiums.xls")))
```




### Data Limitations

## Data Wrangling (Optional Section)




```{r}
attendance$newteam <- str_c(attendance$team, attendance$team_name, sep = " ", collapse = NULL)
standings$newteam <- str_c(standings$team, standings$team_name, sep = " ", collapse = NULL)
games$week <- as.numeric(games$week)
games <- games %>%
  drop_na(week)
data <- games %>%
  left_join(attendance, by = c("home_team" = "newteam", "year", "week"))
data <- data %>%
  left_join(standings, by = c("home_team" = "newteam", "year", "team", "team_name"))
data <- data %>%
  right_join(stadiums, by = c("primary_" = "newteam", "year", "team", "team_name"))

```

```{r}
#| label: training and testing set
data_train <- data %>%
  filter(year != 2019)
data_test <- data %>%
  filter(year == 2019)
```




## Exploratory Data Analysis

## Modeling




```{r}
lm1 <- lm(weekly_attendance ~ home_team + away_team + week + year, data = data_train)
summary(lm1)
plot(lm1)

linreg_model <- linear_reg(mode = "regression", engine = "lm")
knn_model <- nearest_neighbor(mode = "regression",
                              engine = "kknn",
                              neighbors = 8, dist_power = 2)

linear_recipe <- recipe(
  weekly_attendance ~ home_team + away_team + week + year, # response ~ predictors
  data = data_train
)

quadratic_recipe <- recipe(
  weekly_attendance ~ home_team + away_team + week + year, # response ~ predictors
  data = data_train
) |>
  step_poly(week, degree = 2)

interaction_recipe <- recipe(
  weekly_attendance ~ home_team + away_team + week + year, # response ~ predictors
  data = data_train
) |>
  step_interact(terms = ~week:year) # add HR:BB interaction term

knn_recipe <- recipe(
  weekly_attendance ~ home_team + away_team + week + year,
  data = data_train
) |>
  step_normalize(all_numeric_predictors()) |>
  step_dummy(all_nominal_predictors())

all_models <- workflow_set(
  preproc = list(linear = linear_recipe, quadratic = quadratic_recipe,
                 interaction = interaction_recipe, knn = knn_recipe),
  models = list(lr = linreg_model, lr = linreg_model,
                lr = linreg_model, knn = knn_model),
  cross = FALSE # don't mix knn recipes with linear models or vice-versa
)
all_models

set.seed(1112)
data_cv <- vfold_cv(data_train, v = 10)

all_models <- all_models |>
  workflow_map("fit_resamples",
               resamples = data_cv,
               metrics = metric_set(rmse, mae),
               verbose = TRUE) # lets you know where you are in the fitting process

knn_model2 <- nearest_neighbor(mode = "regression", 
                               engine = "kknn",
                               neighbors = tune(), 
                               dist_power = 2)

knn.grid <- expand.grid(neighbors = seq(1,20, by = 1))

all_models2 <- workflow_set(
  preproc = list(linear = linear_recipe, 
                 quadratic = quadratic_recipe,
                 interaction = interaction_recipe, 
                 knn = knn_recipe),
  models = list(lr = linreg_model, 
                lr = linreg_model,
                lr = linreg_model,
                knn2 = knn_model2),
  cross = FALSE 
)

all_models2 <- all_models2 |>
  # add the grid for JUST the knn model
  option_add(grid = knn.grid, id = "knn_knn2") |>
  workflow_map("tune_grid",
               resamples = data_cv,
               metrics = metric_set(rmse), # can add more
               verbose = TRUE)

autoplot(all_models2)

autoplot(all_models2, id = "knn_knn2")

rank_results(all_models2) |>
  dplyr::select(wflow_id, .config, .metric, mean, std_err, rank) |>
  arrange(.metric, rank)

best_k <- all_models2 |> 
  extract_workflow_set_result(id = "knn_knn2") |> 
  select_best(metric = "rmse")
  
my_best_knn <- all_models2 |>
  extract_workflow("knn_knn2") |>
  finalize_workflow(parameters = best_k)

my_best_knn
```

```{r}
best_model_refit <- my_best_knn |>
  fit_resamples(
    resamples = data_cv,
    # save the cross-validated predictions
    control = control_resamples(save_pred = TRUE)
)

predictions_best_model <- best_model_refit |>
  collect_predictions()

cal_plot_regression(
  predictions_best_model,
  truth = weekly_attendance,
  estimate = .pred
)

best_model_refit |>
  cal_validate_linear(
    save_pred = TRUE,
    smooth = TRUE) |> # nonlinear smoothing, use smooth = FALSE for linear transformation
  collect_predictions() |>
  cal_plot_regression(
    truth = weekly_attendance,
    estimate = .pred
  )

calibrate_knn <- predictions_best_model |>
  # instructions for post-processing
  cal_estimate_linear(
    truth = weekly_attendance,
    smooth = TRUE # nonlinear smoothing
  )

knn_fit <- my_best_knn |> fit(
  data = data_train
)

knn_test_pred2 <- knn_fit |>
  augment(new_data = data_test) |>
  # apply the post-processing
  cal_apply(calibrate_knn)

knn_test_pred2
```




## Insights

### Limitations and Future Work

### Reflection (Optional Subsection)

